<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Get started with the Isochrone API</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Mapbox GL JS -->
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.js"></script>
    <link href="https://api.tiles.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.css" rel="stylesheet" />
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #console {
            position: absolute;
            top: 100px;
            left: 20px;
            /* height: 200px; */
            background-color: white;
            padding: 10px;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <div id="console">
        <form id="params">
            <h4>Choose a travel mode:</h4>
            <div>
                <label>
                    <input name="profile" type="radio" value="walking" />
                    <div>Walking</div>
                </label>
                <label>
                    <input name="profile" type="radio" value="cycling" checked />
                    <div>Cycling</div>
                </label>
                <label>
                    <input name="profile" type="radio" value="driving" />
                    <div>Driving</div>
                </label>
            </div>
            <h4>Choose a maximum duration:</h4>
            <div>
                <label>
                    <input name="duration" type="radio" value="10" checked />
                    <div>10 min</div>
                </label>
                <label>
                    <input name="duration" type="radio" value="20" />
                    <div>20 min</div>
                </label>
                <label>
                    <input name="duration" type="radio" value="30" />
                    <div>30 min</div>
                </label>
            </div>
        </form>
    </div>

    <script>
        mapboxgl.accessToken =
            'pk.eyJ1IjoidHRob21wNCIsImEiOiJjbWg4ZnZ4cTUxMGQ5MmtwdWR4MTNnbm40In0.JHg_sbayM5UCtQkYhC2LEA';

const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v11',
    center: [-122.3321, 47.6062], // Seattle center
    zoom: 11.5
});

// Target the params form in the HTML
const params = document.getElementById('params');

// Create variables to use in getIso()
const urlBase = 'https://api.mapbox.com/isochrone/v1/mapbox/';
let profile = 'walking'; // Changed to walking for transit context
let minutes = 10;

    // Array to store minimal stop info (no heavy Marker objects)
    const markers = [];

    // In-memory collection of isochrone polygons; a single source/layer will render these
    let isochroneCollection = { type: 'FeatureCollection', features: [] };

    // small helpers
    const sleep = (ms) => new Promise((res) => setTimeout(res, ms));
    const isoCacheKey = (lon, lat, profile, minutes) => `${lon},${lat}|${profile}|${minutes}`;

    // Process items in small batches to avoid hammering the Mapbox API and the CPU
    async function processInBatches(items, batchSize = 3, delayMs = 300, fn) {
        for (let i = 0; i < items.length; i += batchSize) {
            const batch = items.slice(i, i + batchSize);
            await Promise.all(batch.map((it) => fn(it)));
            // brief pause between batches
            if (i + batchSize < items.length) await sleep(delayMs);
        }
    }

    // Load bus stops from GeoJSON files, add a single stops source & layer, and batch isochrone requests
    async function loadBusStops() {
        try {
            const [rrResponse, linkResponse] = await Promise.all([
                fetch('../assets/data/stops/RR_stops_citylimits.geojson'),
                fetch('../assets/data/stops/link_stops.geojson')
            ]);

            if (!rrResponse.ok) {
                console.error('Failed to fetch RR stops:', rrResponse.status, rrResponse.statusText);
                return;
            }
            if (!linkResponse.ok) {
                console.error('Failed to fetch Link stops:', linkResponse.status, linkResponse.statusText);
                return;
            }

            const rrStops = await rrResponse.json();
            const linkStops = await linkResponse.json();

            const allStops = [...rrStops.features, ...linkStops.features];
            console.log(`Loaded ${allStops.length} total bus stops`);

            // Build a GeoJSON for stops (for a single circle layer) and populate lightweight markers array
            const stopsFeatures = [];
            allStops.forEach((feature, index) => {
                if (!feature || !feature.geometry || !feature.geometry.coordinates) return;

                let coords = feature.geometry.coordinates;
                if (feature.geometry.type === 'MultiPoint' && Array.isArray(coords) && coords.length > 0) coords = coords[0];
                if (Array.isArray(coords) && Array.isArray(coords[0]) && typeof coords[0][0] === 'number') coords = coords[0];

                const lon = Number(coords[0]);
                const lat = Number(coords[1]);
                if (!isFinite(lon) || !isFinite(lat)) return;

                stopsFeatures.push({
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: [lon, lat] },
                    properties: feature.properties || {},
                    id: index
                });

                // store minimal data for later isochrone requests
                markers.push({ lngLat: { lng: lon, lat: lat }, properties: feature.properties || {}, index });
            });

            // Add or update a single stops source + circle layer (cheap compared to many Marker objects)
            const stopsGeo = { type: 'FeatureCollection', features: stopsFeatures };
            if (map.getSource('stops')) {
                map.getSource('stops').setData(stopsGeo);
            } else {
                map.addSource('stops', { type: 'geojson', data: stopsGeo });
                map.addLayer({
                    id: 'stops-layer',
                    type: 'circle',
                    source: 'stops',
                    paint: { 'circle-radius': 4, 'circle-color': '#314ccd', 'circle-stroke-width': 1, 'circle-stroke-color': '#fff' }
                });
            }

            // Ensure the isochrone source/layer exists (empty to start)
            if (!map.getSource('isochrones')) {
                map.addSource('isochrones', { type: 'geojson', data: isochroneCollection });
                map.addLayer({
                    id: 'isoLayer',
                    type: 'fill',
                    source: 'isochrones',
                    paint: { 'fill-color': '#5a3fc0', 'fill-opacity': 0.25 }
                }, 'poi-label');
            }

            // Batch process isochrone requests to reduce CPU/network spikes
            await processInBatches(markers, 3, 300, async (m) => {
                await getIso(m.lngLat.lng, m.lngLat.lat, m.index);
            });

        } catch (error) {
            console.error('Error loading bus stops:', error);
        }
    }

// Optimized getIso: caching + update a single isochrone source (isochrones)
async function getIso(lon, lat, index) {
    try {
        const key = isoCacheKey(lon, lat, profile, minutes);
        let data = null;

        // Try local cache first
        const cached = localStorage.getItem(key);
        if (cached) {
            try { data = JSON.parse(cached); } catch (e) { localStorage.removeItem(key); }
        }

        if (!data) {
            const url = `${urlBase}${profile}/${lon},${lat}?contours_minutes=${minutes}&polygons=true&access_token=${mapboxgl.accessToken}`;
            const resp = await fetch(url);
            if (!resp.ok) {
                console.warn('Isochrone request failed', resp.status, resp.statusText);
                return;
            }
            data = await resp.json();
            try { localStorage.setItem(key, JSON.stringify(data)); } catch (e) { /* ignore storage quota issues */ }
        }

        const feature = data && data.features && data.features[0];
        if (!feature) return;

        // tag feature so we can replace it later
        feature.properties = feature.properties || {};
        feature.properties.sourceIndex = index;
        feature.properties._lon = lon;
        feature.properties._lat = lat;

        // Replace existing feature from same sourceIndex or append
        const existing = isochroneCollection.features.findIndex(f => f.properties && f.properties.sourceIndex === index);
        if (existing > -1) isochroneCollection.features[existing] = feature;
        else isochroneCollection.features.push(feature);

        // update the single source
        if (map.getSource('isochrones')) map.getSource('isochrones').setData(isochroneCollection);
    } catch (err) {
        console.error('getIso error', err);
    }
}

// Function to update all isochrones when parameters change
async function updateAllIsochrones() {
    // clear existing collection then re-request in batches
    isochroneCollection.features = [];
    if (map.getSource('isochrones')) map.getSource('isochrones').setData(isochroneCollection);
    await processInBatches(markers, 3, 300, async (m) => {
        await getIso(m.lngLat.lng, m.lngLat.lat, m.index);
    });
}

// When a user changes the value of profile or duration
params.addEventListener('change', (event) => {
    if (event.target.name === 'profile') {
        profile = event.target.value;
    } else if (event.target.name === 'duration') {
        minutes = event.target.value;
    }
    // fire-and-forget; function handles batching
    updateAllIsochrones();
});

map.on('load', () => {
    // Load and render all bus stops (this will also start batched isochrone requests)
    loadBusStops();
});
    </script>
</body>

</html>